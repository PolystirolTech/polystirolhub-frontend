// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * PolystirolHub Backend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AutoCheck,
  AutoCheck1,
  AwardBadgeRequest,
  Badge,
  BadgeType,
  ConditionKey,
  Description,
  HTTPValidationError,
  Image,
  Name,
  ResponseGetMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGet,
  RewardBalance,
  RewardBalance1,
  RewardXp,
  RewardXp1,
  TargetValue,
  UnicodeChar,
} from '../models/index';
import {
    AutoCheckFromJSON,
    AutoCheckToJSON,
    AutoCheck1FromJSON,
    AutoCheck1ToJSON,
    AwardBadgeRequestFromJSON,
    AwardBadgeRequestToJSON,
    BadgeFromJSON,
    BadgeToJSON,
    BadgeTypeFromJSON,
    BadgeTypeToJSON,
    ConditionKeyFromJSON,
    ConditionKeyToJSON,
    DescriptionFromJSON,
    DescriptionToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    ImageFromJSON,
    ImageToJSON,
    NameFromJSON,
    NameToJSON,
    ResponseGetMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGetFromJSON,
    ResponseGetMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGetToJSON,
    RewardBalanceFromJSON,
    RewardBalanceToJSON,
    RewardBalance1FromJSON,
    RewardBalance1ToJSON,
    RewardXpFromJSON,
    RewardXpToJSON,
    RewardXp1FromJSON,
    RewardXp1ToJSON,
    TargetValueFromJSON,
    TargetValueToJSON,
    UnicodeCharFromJSON,
    UnicodeCharToJSON,
} from '../models/index';

export interface AwardBadgeApiV1AdminBadgesBadgeIdAwardUserIdPostRequest {
    badgeId: any;
    userId: any;
    awardBadgeRequest: AwardBadgeRequest;
}

export interface CheckBadgeForUserApiV1AdminBadgesBadgeIdCheckUserIdPostRequest {
    badgeId: any;
    userId: any;
}

export interface CreateBadgeApiV1AdminBadgesPostRequest {
    name: any | null;
    badgeType: any | null;
    image: any | null;
    description?: Description;
    conditionKey?: ConditionKey;
    targetValue?: TargetValue;
    autoCheck?: AutoCheck;
    rewardXp?: RewardXp;
    rewardBalance?: RewardBalance;
    unicodeChar?: UnicodeChar;
}

export interface DeleteBadgeApiV1AdminBadgesBadgeIdDeleteRequest {
    badgeId: any;
}

export interface GetBadgeAdminApiV1AdminBadgesBadgeIdGetRequest {
    badgeId: any;
}

export interface GetBadgeApiV1BadgesBadgeIdGetRequest {
    badgeId: any;
}

export interface GetMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGetRequest {
    playerUuid: any;
}

export interface RevokeBadgeApiV1AdminBadgesBadgeIdRevokeUserIdDeleteRequest {
    badgeId: any;
    userId: any;
}

export interface SelectBadgeApiV1BadgesMeSelectPatchRequest {
    badgeId: any;
}

export interface UpdateBadgeApiV1AdminBadgesBadgeIdPutRequest {
    badgeId: any;
    name?: Name;
    description?: Description;
    badgeType?: BadgeType;
    image?: Image;
    conditionKey?: ConditionKey;
    targetValue?: TargetValue;
    autoCheck?: AutoCheck1;
    rewardXp?: RewardXp1;
    rewardBalance?: RewardBalance1;
    unicodeChar?: UnicodeChar;
}

/**
 * 
 */
export class BadgesApi extends runtime.BaseAPI {

    /**
     * Выдача бэйджа пользователю (только для админов)
     * Award Badge
     */
    async awardBadgeApiV1AdminBadgesBadgeIdAwardUserIdPostRaw(requestParameters: AwardBadgeApiV1AdminBadgesBadgeIdAwardUserIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.badgeId === null || requestParameters.badgeId === undefined) {
            throw new runtime.RequiredError('badgeId','Required parameter requestParameters.badgeId was null or undefined when calling awardBadgeApiV1AdminBadgesBadgeIdAwardUserIdPost.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling awardBadgeApiV1AdminBadgesBadgeIdAwardUserIdPost.');
        }

        if (requestParameters.awardBadgeRequest === null || requestParameters.awardBadgeRequest === undefined) {
            throw new runtime.RequiredError('awardBadgeRequest','Required parameter requestParameters.awardBadgeRequest was null or undefined when calling awardBadgeApiV1AdminBadgesBadgeIdAwardUserIdPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/admin/badges/{badge_id}/award/{user_id}`.replace(`{${"badge_id"}}`, encodeURIComponent(String(requestParameters.badgeId))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AwardBadgeRequestToJSON(requestParameters.awardBadgeRequest),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Выдача бэйджа пользователю (только для админов)
     * Award Badge
     */
    async awardBadgeApiV1AdminBadgesBadgeIdAwardUserIdPost(requestParameters: AwardBadgeApiV1AdminBadgesBadgeIdAwardUserIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.awardBadgeApiV1AdminBadgesBadgeIdAwardUserIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Проверка конкретного бейджа для пользователя (только для админов)
     * Check Badge For User
     */
    async checkBadgeForUserApiV1AdminBadgesBadgeIdCheckUserIdPostRaw(requestParameters: CheckBadgeForUserApiV1AdminBadgesBadgeIdCheckUserIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.badgeId === null || requestParameters.badgeId === undefined) {
            throw new runtime.RequiredError('badgeId','Required parameter requestParameters.badgeId was null or undefined when calling checkBadgeForUserApiV1AdminBadgesBadgeIdCheckUserIdPost.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling checkBadgeForUserApiV1AdminBadgesBadgeIdCheckUserIdPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/admin/badges/{badge_id}/check/{user_id}`.replace(`{${"badge_id"}}`, encodeURIComponent(String(requestParameters.badgeId))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Проверка конкретного бейджа для пользователя (только для админов)
     * Check Badge For User
     */
    async checkBadgeForUserApiV1AdminBadgesBadgeIdCheckUserIdPost(requestParameters: CheckBadgeForUserApiV1AdminBadgesBadgeIdCheckUserIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.checkBadgeForUserApiV1AdminBadgesBadgeIdCheckUserIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Ручной запуск проверки периодических бейджей (только для админов)
     * Check Periodic Badges Endpoint
     */
    async checkPeriodicBadgesEndpointApiV1AdminBadgesCheckPeriodicPostRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/admin/badges/check-periodic`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Ручной запуск проверки периодических бейджей (только для админов)
     * Check Periodic Badges Endpoint
     */
    async checkPeriodicBadgesEndpointApiV1AdminBadgesCheckPeriodicPost(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.checkPeriodicBadgesEndpointApiV1AdminBadgesCheckPeriodicPostRaw(initOverrides);
        return await response.value();
    }

    /**
     * Создание бэйджа (только для админов)
     * Create Badge
     */
    async createBadgeApiV1AdminBadgesPostRaw(requestParameters: CreateBadgeApiV1AdminBadgesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Badge>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createBadgeApiV1AdminBadgesPost.');
        }

        if (requestParameters.badgeType === null || requestParameters.badgeType === undefined) {
            throw new runtime.RequiredError('badgeType','Required parameter requestParameters.badgeType was null or undefined when calling createBadgeApiV1AdminBadgesPost.');
        }

        if (requestParameters.image === null || requestParameters.image === undefined) {
            throw new runtime.RequiredError('image','Required parameter requestParameters.image was null or undefined when calling createBadgeApiV1AdminBadgesPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', new Blob([JSON.stringify(anyToJSON(requestParameters.name))], { type: "application/json", }));
                    }

        if (requestParameters.description !== undefined) {
            formParams.append('description', new Blob([JSON.stringify(DescriptionToJSON(requestParameters.description))], { type: "application/json", }));
                    }

        if (requestParameters.badgeType !== undefined) {
            formParams.append('badge_type', new Blob([JSON.stringify(anyToJSON(requestParameters.badgeType))], { type: "application/json", }));
                    }

        if (requestParameters.image !== undefined) {
            formParams.append('image', new Blob([JSON.stringify(anyToJSON(requestParameters.image))], { type: "application/json", }));
                    }

        if (requestParameters.conditionKey !== undefined) {
            formParams.append('condition_key', new Blob([JSON.stringify(ConditionKeyToJSON(requestParameters.conditionKey))], { type: "application/json", }));
                    }

        if (requestParameters.targetValue !== undefined) {
            formParams.append('target_value', new Blob([JSON.stringify(TargetValueToJSON(requestParameters.targetValue))], { type: "application/json", }));
                    }

        if (requestParameters.autoCheck !== undefined) {
            formParams.append('auto_check', new Blob([JSON.stringify(AutoCheckToJSON(requestParameters.autoCheck))], { type: "application/json", }));
                    }

        if (requestParameters.rewardXp !== undefined) {
            formParams.append('reward_xp', new Blob([JSON.stringify(RewardXpToJSON(requestParameters.rewardXp))], { type: "application/json", }));
                    }

        if (requestParameters.rewardBalance !== undefined) {
            formParams.append('reward_balance', new Blob([JSON.stringify(RewardBalanceToJSON(requestParameters.rewardBalance))], { type: "application/json", }));
                    }

        if (requestParameters.unicodeChar !== undefined) {
            formParams.append('unicode_char', new Blob([JSON.stringify(UnicodeCharToJSON(requestParameters.unicodeChar))], { type: "application/json", }));
                    }

        const response = await this.request({
            path: `/api/v1/admin/badges`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BadgeFromJSON(jsonValue));
    }

    /**
     * Создание бэйджа (только для админов)
     * Create Badge
     */
    async createBadgeApiV1AdminBadgesPost(requestParameters: CreateBadgeApiV1AdminBadgesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Badge> {
        const response = await this.createBadgeApiV1AdminBadgesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удаление бэйджа (только для админов)
     * Delete Badge
     */
    async deleteBadgeApiV1AdminBadgesBadgeIdDeleteRaw(requestParameters: DeleteBadgeApiV1AdminBadgesBadgeIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.badgeId === null || requestParameters.badgeId === undefined) {
            throw new runtime.RequiredError('badgeId','Required parameter requestParameters.badgeId was null or undefined when calling deleteBadgeApiV1AdminBadgesBadgeIdDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/admin/badges/{badge_id}`.replace(`{${"badge_id"}}`, encodeURIComponent(String(requestParameters.badgeId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Удаление бэйджа (только для админов)
     * Delete Badge
     */
    async deleteBadgeApiV1AdminBadgesBadgeIdDelete(requestParameters: DeleteBadgeApiV1AdminBadgesBadgeIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteBadgeApiV1AdminBadgesBadgeIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Снять выбранный бэйджик
     * Deselect Badge
     */
    async deselectBadgeApiV1BadgesMeSelectDeleteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/badges/me/select`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Снять выбранный бэйджик
     * Deselect Badge
     */
    async deselectBadgeApiV1BadgesMeSelectDelete(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deselectBadgeApiV1BadgesMeSelectDeleteRaw(initOverrides);
        return await response.value();
    }

    /**
     * Возвращает список всех доступных condition_key с описаниями. Доступно всем пользователям для понимания возможных условий.
     * Get Available Conditions
     */
    async getAvailableConditionsApiV1BadgesConditionsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/badges/conditions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Возвращает список всех доступных condition_key с описаниями. Доступно всем пользователям для понимания возможных условий.
     * Get Available Conditions
     */
    async getAvailableConditionsApiV1BadgesConditionsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getAvailableConditionsApiV1BadgesConditionsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Получение бэйджа (только для админов)
     * Get Badge Admin
     */
    async getBadgeAdminApiV1AdminBadgesBadgeIdGetRaw(requestParameters: GetBadgeAdminApiV1AdminBadgesBadgeIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Badge>> {
        if (requestParameters.badgeId === null || requestParameters.badgeId === undefined) {
            throw new runtime.RequiredError('badgeId','Required parameter requestParameters.badgeId was null or undefined when calling getBadgeAdminApiV1AdminBadgesBadgeIdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/admin/badges/{badge_id}`.replace(`{${"badge_id"}}`, encodeURIComponent(String(requestParameters.badgeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BadgeFromJSON(jsonValue));
    }

    /**
     * Получение бэйджа (только для админов)
     * Get Badge Admin
     */
    async getBadgeAdminApiV1AdminBadgesBadgeIdGet(requestParameters: GetBadgeAdminApiV1AdminBadgesBadgeIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Badge> {
        const response = await this.getBadgeAdminApiV1AdminBadgesBadgeIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Публичное получение информации о бэйдже
     * Get Badge
     */
    async getBadgeApiV1BadgesBadgeIdGetRaw(requestParameters: GetBadgeApiV1BadgesBadgeIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Badge>> {
        if (requestParameters.badgeId === null || requestParameters.badgeId === undefined) {
            throw new runtime.RequiredError('badgeId','Required parameter requestParameters.badgeId was null or undefined when calling getBadgeApiV1BadgesBadgeIdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/badges/{badge_id}`.replace(`{${"badge_id"}}`, encodeURIComponent(String(requestParameters.badgeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BadgeFromJSON(jsonValue));
    }

    /**
     * Публичное получение информации о бэйдже
     * Get Badge
     */
    async getBadgeApiV1BadgesBadgeIdGet(requestParameters: GetBadgeApiV1BadgesBadgeIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Badge> {
        const response = await this.getBadgeApiV1BadgesBadgeIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Публичный список всех доступных бэджиков
     * Get Badges
     */
    async getBadgesApiV1BadgesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/badges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Публичный список всех доступных бэджиков
     * Get Badges
     */
    async getBadgesApiV1BadgesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getBadgesApiV1BadgesGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Получить выбранный бэджик игрока Minecraft по его UUID
     * Get Minecraft Player Selected Badge
     */
    async getMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGetRaw(requestParameters: GetMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponseGetMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGet>> {
        if (requestParameters.playerUuid === null || requestParameters.playerUuid === undefined) {
            throw new runtime.RequiredError('playerUuid','Required parameter requestParameters.playerUuid was null or undefined when calling getMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/badges/minecraft/{player_uuid}`.replace(`{${"player_uuid"}}`, encodeURIComponent(String(requestParameters.playerUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResponseGetMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGetFromJSON(jsonValue));
    }

    /**
     * Получить выбранный бэджик игрока Minecraft по его UUID
     * Get Minecraft Player Selected Badge
     */
    async getMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGet(requestParameters: GetMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponseGetMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGet> {
        const response = await this.getMinecraftPlayerSelectedBadgeApiV1BadgesMinecraftPlayerUuidGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить список моих бэджиков
     * Get My Badges
     */
    async getMyBadgesApiV1BadgesMeGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/badges/me`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить список моих бэджиков
     * Get My Badges
     */
    async getMyBadgesApiV1BadgesMeGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getMyBadgesApiV1BadgesMeGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Список всех бэджиков (только для админов)
     * List Badges
     */
    async listBadgesApiV1AdminBadgesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/admin/badges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Список всех бэджиков (только для админов)
     * List Badges
     */
    async listBadgesApiV1AdminBadgesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.listBadgesApiV1AdminBadgesGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Отзыв бэйджа у пользователя (только для админов)
     * Revoke Badge
     */
    async revokeBadgeApiV1AdminBadgesBadgeIdRevokeUserIdDeleteRaw(requestParameters: RevokeBadgeApiV1AdminBadgesBadgeIdRevokeUserIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.badgeId === null || requestParameters.badgeId === undefined) {
            throw new runtime.RequiredError('badgeId','Required parameter requestParameters.badgeId was null or undefined when calling revokeBadgeApiV1AdminBadgesBadgeIdRevokeUserIdDelete.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling revokeBadgeApiV1AdminBadgesBadgeIdRevokeUserIdDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/admin/badges/{badge_id}/revoke/{user_id}`.replace(`{${"badge_id"}}`, encodeURIComponent(String(requestParameters.badgeId))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Отзыв бэйджа у пользователя (только для админов)
     * Revoke Badge
     */
    async revokeBadgeApiV1AdminBadgesBadgeIdRevokeUserIdDelete(requestParameters: RevokeBadgeApiV1AdminBadgesBadgeIdRevokeUserIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.revokeBadgeApiV1AdminBadgesBadgeIdRevokeUserIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Выбрать бэйджик для отображения
     * Select Badge
     */
    async selectBadgeApiV1BadgesMeSelectPatchRaw(requestParameters: SelectBadgeApiV1BadgesMeSelectPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.badgeId === null || requestParameters.badgeId === undefined) {
            throw new runtime.RequiredError('badgeId','Required parameter requestParameters.badgeId was null or undefined when calling selectBadgeApiV1BadgesMeSelectPatch.');
        }

        const queryParameters: any = {};

        if (requestParameters.badgeId !== undefined) {
            queryParameters['badge_id'] = requestParameters.badgeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const response = await this.request({
            path: `/api/v1/badges/me/select`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Выбрать бэйджик для отображения
     * Select Badge
     */
    async selectBadgeApiV1BadgesMeSelectPatch(requestParameters: SelectBadgeApiV1BadgesMeSelectPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.selectBadgeApiV1BadgesMeSelectPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновление бэйджа (только для админов)
     * Update Badge
     */
    async updateBadgeApiV1AdminBadgesBadgeIdPutRaw(requestParameters: UpdateBadgeApiV1AdminBadgesBadgeIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Badge>> {
        if (requestParameters.badgeId === null || requestParameters.badgeId === undefined) {
            throw new runtime.RequiredError('badgeId','Required parameter requestParameters.badgeId was null or undefined when calling updateBadgeApiV1AdminBadgesBadgeIdPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2PasswordBearer", []);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', new Blob([JSON.stringify(NameToJSON(requestParameters.name))], { type: "application/json", }));
                    }

        if (requestParameters.description !== undefined) {
            formParams.append('description', new Blob([JSON.stringify(DescriptionToJSON(requestParameters.description))], { type: "application/json", }));
                    }

        if (requestParameters.badgeType !== undefined) {
            formParams.append('badge_type', new Blob([JSON.stringify(BadgeTypeToJSON(requestParameters.badgeType))], { type: "application/json", }));
                    }

        if (requestParameters.image !== undefined) {
            formParams.append('image', new Blob([JSON.stringify(ImageToJSON(requestParameters.image))], { type: "application/json", }));
                    }

        if (requestParameters.conditionKey !== undefined) {
            formParams.append('condition_key', new Blob([JSON.stringify(ConditionKeyToJSON(requestParameters.conditionKey))], { type: "application/json", }));
                    }

        if (requestParameters.targetValue !== undefined) {
            formParams.append('target_value', new Blob([JSON.stringify(TargetValueToJSON(requestParameters.targetValue))], { type: "application/json", }));
                    }

        if (requestParameters.autoCheck !== undefined) {
            formParams.append('auto_check', new Blob([JSON.stringify(AutoCheck1ToJSON(requestParameters.autoCheck))], { type: "application/json", }));
                    }

        if (requestParameters.rewardXp !== undefined) {
            formParams.append('reward_xp', new Blob([JSON.stringify(RewardXp1ToJSON(requestParameters.rewardXp))], { type: "application/json", }));
                    }

        if (requestParameters.rewardBalance !== undefined) {
            formParams.append('reward_balance', new Blob([JSON.stringify(RewardBalance1ToJSON(requestParameters.rewardBalance))], { type: "application/json", }));
                    }

        if (requestParameters.unicodeChar !== undefined) {
            formParams.append('unicode_char', new Blob([JSON.stringify(UnicodeCharToJSON(requestParameters.unicodeChar))], { type: "application/json", }));
                    }

        const response = await this.request({
            path: `/api/v1/admin/badges/{badge_id}`.replace(`{${"badge_id"}}`, encodeURIComponent(String(requestParameters.badgeId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BadgeFromJSON(jsonValue));
    }

    /**
     * Обновление бэйджа (только для админов)
     * Update Badge
     */
    async updateBadgeApiV1AdminBadgesBadgeIdPut(requestParameters: UpdateBadgeApiV1AdminBadgesBadgeIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Badge> {
        const response = await this.updateBadgeApiV1AdminBadgesBadgeIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

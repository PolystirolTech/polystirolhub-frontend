/* tslint:disable */
/* eslint-disable */
/**
 * PolystirolHub Backend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
	ConditionKey,
	Description,
	HTTPValidationError,
	IsActive,
	Name,
	Quest,
	QuestType,
	RewardXp1,
	TargetValue,
} from '../models/index';
import {
	ConditionKeyFromJSON,
	ConditionKeyToJSON,
	DescriptionFromJSON,
	DescriptionToJSON,
	HTTPValidationErrorFromJSON,
	HTTPValidationErrorToJSON,
	IsActiveFromJSON,
	IsActiveToJSON,
	NameFromJSON,
	NameToJSON,
	QuestFromJSON,
	QuestToJSON,
	QuestTypeFromJSON,
	QuestTypeToJSON,
	RewardXp1FromJSON,
	RewardXp1ToJSON,
	TargetValueFromJSON,
	TargetValueToJSON,
} from '../models/index';

export interface CreateQuestApiV1AdminQuestsPostRequest {
	name: any | null;
	questType: any | null;
	conditionKey: any | null;
	targetValue: any | null;
	description?: Description;
	rewardXp?: any | null;
	isActive?: any | null;
}

export interface DeleteQuestApiV1AdminQuestsQuestIdDeleteRequest {
	questId: any;
}

export interface GetQuestAdminApiV1AdminQuestsQuestIdGetRequest {
	questId: any;
}

export interface UpdateQuestApiV1AdminQuestsQuestIdPutRequest {
	questId: any;
	name?: Name;
	description?: Description;
	questType?: QuestType;
	conditionKey?: ConditionKey;
	targetValue?: TargetValue;
	rewardXp?: RewardXp1;
	isActive?: IsActive;
}

/**
 *
 */
export class QuestsApi extends runtime.BaseAPI {
	/**
	 * Создание квеста (только для админов)
	 * Create Quest
	 */
	async createQuestApiV1AdminQuestsPostRaw(
		requestParameters: CreateQuestApiV1AdminQuestsPostRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Quest>> {
		if (requestParameters.name === null || requestParameters.name === undefined) {
			throw new runtime.RequiredError(
				'name',
				'Required parameter requestParameters.name was null or undefined when calling createQuestApiV1AdminQuestsPost.'
			);
		}

		if (requestParameters.questType === null || requestParameters.questType === undefined) {
			throw new runtime.RequiredError(
				'questType',
				'Required parameter requestParameters.questType was null or undefined when calling createQuestApiV1AdminQuestsPost.'
			);
		}

		if (requestParameters.conditionKey === null || requestParameters.conditionKey === undefined) {
			throw new runtime.RequiredError(
				'conditionKey',
				'Required parameter requestParameters.conditionKey was null or undefined when calling createQuestApiV1AdminQuestsPost.'
			);
		}

		if (requestParameters.targetValue === null || requestParameters.targetValue === undefined) {
			throw new runtime.RequiredError(
				'targetValue',
				'Required parameter requestParameters.targetValue was null or undefined when calling createQuestApiV1AdminQuestsPost.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.accessToken) {
			// oauth required
			headerParameters['Authorization'] = await this.configuration.accessToken(
				'OAuth2PasswordBearer',
				[]
			);
		}

		const consumes: runtime.Consume[] = [{ contentType: 'application/x-www-form-urlencoded' }];
		// @ts-ignore: canConsumeForm may be unused
		const canConsumeForm = runtime.canConsumeForm(consumes);

		let formParams: { append(param: string, value: any): any };
		let useForm = false;
		if (useForm) {
			formParams = new FormData();
		} else {
			formParams = new URLSearchParams();
		}

		if (requestParameters.name !== undefined) {
			formParams.append(
				'name',
				new Blob([JSON.stringify(runtime.anyToJSON(requestParameters.name))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.description !== undefined) {
			formParams.append(
				'description',
				new Blob([JSON.stringify(DescriptionToJSON(requestParameters.description))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.questType !== undefined) {
			formParams.append(
				'quest_type',
				new Blob([JSON.stringify(runtime.anyToJSON(requestParameters.questType))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.conditionKey !== undefined) {
			formParams.append(
				'condition_key',
				new Blob([JSON.stringify(runtime.anyToJSON(requestParameters.conditionKey))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.targetValue !== undefined) {
			formParams.append(
				'target_value',
				new Blob([JSON.stringify(runtime.anyToJSON(requestParameters.targetValue))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.rewardXp !== undefined) {
			formParams.append(
				'reward_xp',
				new Blob([JSON.stringify(runtime.anyToJSON(requestParameters.rewardXp))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.isActive !== undefined) {
			formParams.append(
				'is_active',
				new Blob([JSON.stringify(runtime.anyToJSON(requestParameters.isActive))], {
					type: 'application/json',
				})
			);
		}

		const response = await this.request(
			{
				path: `/api/v1/admin/quests`,
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: formParams,
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => QuestFromJSON(jsonValue));
	}

	/**
	 * Создание квеста (только для админов)
	 * Create Quest
	 */
	async createQuestApiV1AdminQuestsPost(
		requestParameters: CreateQuestApiV1AdminQuestsPostRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Quest> {
		const response = await this.createQuestApiV1AdminQuestsPostRaw(
			requestParameters,
			initOverrides
		);
		return await response.value();
	}

	/**
	 * Удаление квеста (soft delete через is_active=False) (только для админов)
	 * Delete Quest
	 */
	async deleteQuestApiV1AdminQuestsQuestIdDeleteRaw(
		requestParameters: DeleteQuestApiV1AdminQuestsQuestIdDeleteRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<any>> {
		if (requestParameters.questId === null || requestParameters.questId === undefined) {
			throw new runtime.RequiredError(
				'questId',
				'Required parameter requestParameters.questId was null or undefined when calling deleteQuestApiV1AdminQuestsQuestIdDelete.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.accessToken) {
			// oauth required
			headerParameters['Authorization'] = await this.configuration.accessToken(
				'OAuth2PasswordBearer',
				[]
			);
		}

		const response = await this.request(
			{
				path: `/api/v1/admin/quests/{quest_id}`.replace(
					`{${'quest_id'}}`,
					encodeURIComponent(String(requestParameters.questId))
				),
				method: 'DELETE',
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides
		);

		if (this.isJsonMime(response.headers.get('content-type'))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Удаление квеста (soft delete через is_active=False) (только для админов)
	 * Delete Quest
	 */
	async deleteQuestApiV1AdminQuestsQuestIdDelete(
		requestParameters: DeleteQuestApiV1AdminQuestsQuestIdDeleteRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<any> {
		const response = await this.deleteQuestApiV1AdminQuestsQuestIdDeleteRaw(
			requestParameters,
			initOverrides
		);
		return await response.value();
	}

	/**
	 * Получить список моих квестов с прогрессом
	 * Get My Quests
	 */
	async getMyQuestsApiV1QuestsMeGetRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<any>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.accessToken) {
			// oauth required
			headerParameters['Authorization'] = await this.configuration.accessToken(
				'OAuth2PasswordBearer',
				[]
			);
		}

		const response = await this.request(
			{
				path: `/api/v1/quests/me`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides
		);

		if (this.isJsonMime(response.headers.get('content-type'))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Получить список моих квестов с прогрессом
	 * Get My Quests
	 */
	async getMyQuestsApiV1QuestsMeGet(
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<any> {
		const response = await this.getMyQuestsApiV1QuestsMeGetRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Получение квеста (только для админов)
	 * Get Quest Admin
	 */
	async getQuestAdminApiV1AdminQuestsQuestIdGetRaw(
		requestParameters: GetQuestAdminApiV1AdminQuestsQuestIdGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Quest>> {
		if (requestParameters.questId === null || requestParameters.questId === undefined) {
			throw new runtime.RequiredError(
				'questId',
				'Required parameter requestParameters.questId was null or undefined when calling getQuestAdminApiV1AdminQuestsQuestIdGet.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.accessToken) {
			// oauth required
			headerParameters['Authorization'] = await this.configuration.accessToken(
				'OAuth2PasswordBearer',
				[]
			);
		}

		const response = await this.request(
			{
				path: `/api/v1/admin/quests/{quest_id}`.replace(
					`{${'quest_id'}}`,
					encodeURIComponent(String(requestParameters.questId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => QuestFromJSON(jsonValue));
	}

	/**
	 * Получение квеста (только для админов)
	 * Get Quest Admin
	 */
	async getQuestAdminApiV1AdminQuestsQuestIdGet(
		requestParameters: GetQuestAdminApiV1AdminQuestsQuestIdGetRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Quest> {
		const response = await this.getQuestAdminApiV1AdminQuestsQuestIdGetRaw(
			requestParameters,
			initOverrides
		);
		return await response.value();
	}

	/**
	 * Публичный список всех активных квестов
	 * Get Quests
	 */
	async getQuestsApiV1QuestsGetRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<any>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		const response = await this.request(
			{
				path: `/api/v1/quests`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides
		);

		if (this.isJsonMime(response.headers.get('content-type'))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Публичный список всех активных квестов
	 * Get Quests
	 */
	async getQuestsApiV1QuestsGet(
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<any> {
		const response = await this.getQuestsApiV1QuestsGetRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Список всех квестов (только для админов)
	 * List Quests
	 */
	async listQuestsApiV1AdminQuestsGetRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<any>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.accessToken) {
			// oauth required
			headerParameters['Authorization'] = await this.configuration.accessToken(
				'OAuth2PasswordBearer',
				[]
			);
		}

		const response = await this.request(
			{
				path: `/api/v1/admin/quests`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters,
			},
			initOverrides
		);

		if (this.isJsonMime(response.headers.get('content-type'))) {
			return new runtime.JSONApiResponse<any>(response);
		} else {
			return new runtime.TextApiResponse(response) as any;
		}
	}

	/**
	 * Список всех квестов (только для админов)
	 * List Quests
	 */
	async listQuestsApiV1AdminQuestsGet(
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<any> {
		const response = await this.listQuestsApiV1AdminQuestsGetRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Обновление квеста (только для админов)
	 * Update Quest
	 */
	async updateQuestApiV1AdminQuestsQuestIdPutRaw(
		requestParameters: UpdateQuestApiV1AdminQuestsQuestIdPutRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Quest>> {
		if (requestParameters.questId === null || requestParameters.questId === undefined) {
			throw new runtime.RequiredError(
				'questId',
				'Required parameter requestParameters.questId was null or undefined when calling updateQuestApiV1AdminQuestsQuestIdPut.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.accessToken) {
			// oauth required
			headerParameters['Authorization'] = await this.configuration.accessToken(
				'OAuth2PasswordBearer',
				[]
			);
		}

		const consumes: runtime.Consume[] = [{ contentType: 'application/x-www-form-urlencoded' }];
		// @ts-ignore: canConsumeForm may be unused
		const canConsumeForm = runtime.canConsumeForm(consumes);

		let formParams: { append(param: string, value: any): any };
		let useForm = false;
		if (useForm) {
			formParams = new FormData();
		} else {
			formParams = new URLSearchParams();
		}

		if (requestParameters.name !== undefined) {
			formParams.append(
				'name',
				new Blob([JSON.stringify(NameToJSON(requestParameters.name))], { type: 'application/json' })
			);
		}

		if (requestParameters.description !== undefined) {
			formParams.append(
				'description',
				new Blob([JSON.stringify(DescriptionToJSON(requestParameters.description))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.questType !== undefined) {
			formParams.append(
				'quest_type',
				new Blob([JSON.stringify(QuestTypeToJSON(requestParameters.questType))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.conditionKey !== undefined) {
			formParams.append(
				'condition_key',
				new Blob([JSON.stringify(ConditionKeyToJSON(requestParameters.conditionKey))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.targetValue !== undefined) {
			formParams.append(
				'target_value',
				new Blob([JSON.stringify(TargetValueToJSON(requestParameters.targetValue))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.rewardXp !== undefined) {
			formParams.append(
				'reward_xp',
				new Blob([JSON.stringify(RewardXp1ToJSON(requestParameters.rewardXp))], {
					type: 'application/json',
				})
			);
		}

		if (requestParameters.isActive !== undefined) {
			formParams.append(
				'is_active',
				new Blob([JSON.stringify(IsActiveToJSON(requestParameters.isActive))], {
					type: 'application/json',
				})
			);
		}

		const response = await this.request(
			{
				path: `/api/v1/admin/quests/{quest_id}`.replace(
					`{${'quest_id'}}`,
					encodeURIComponent(String(requestParameters.questId))
				),
				method: 'PUT',
				headers: headerParameters,
				query: queryParameters,
				body: formParams,
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => QuestFromJSON(jsonValue));
	}

	/**
	 * Обновление квеста (только для админов)
	 * Update Quest
	 */
	async updateQuestApiV1AdminQuestsQuestIdPut(
		requestParameters: UpdateQuestApiV1AdminQuestsQuestIdPutRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Quest> {
		const response = await this.updateQuestApiV1AdminQuestsQuestIdPutRaw(
			requestParameters,
			initOverrides
		);
		return await response.value();
	}
}
